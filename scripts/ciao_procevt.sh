#!/bin/sh
#
unalias -a
export LC_COLLATE=C
###########################################################
## process `evt2 file' generated by `chandra_repro'      ##
## to produce a `clean evt2 file'                        ##
## (remove point source and flares)                      ##
## for later image and spectral analysis                 ##
##                                                       ##
## NOTES:                                                ##
## based on previous `ciao_process_evt2.sh'              ##
## support ACIS-I(chip: 0-3) and ACIS-S(chip: 7)         ##
## determine by check `DETNAM' for chip number           ##
## if `DETNAM' has `0123', then `ACIS-I'                 ##
## if `DETNAM' has `7', then `ACIS-S'                    ##
##                                                       ##
## Weitian LI <liweitianux@gmail.com>#                   ##
## 2012/08/16                                            ##
###########################################################
##
VERSION="v3.0"
UPDATED="2015/06/02"
##
## ChangeLogs:
## v3.0, 2015/06/02, Aaron LI
##   * Added 'unalias -a' and 'export LC_COLLATE=C'
##   * Replaced 'grep' with '\grep', 'ls' with '\ls'
##   * Copy needed pfiles to current working directory, and
##     set environment variable $PFILES to use these first.
## v2.2, 2014/10/30, Weitian LI
##   small fix to the generation of chips script:
##   changed '>>' to '>'
## v2.1, 2012/08/16, Weitian LI
##   improve invoke `chips', run it in a separate terminal
##


## error code {{{
ERR_USG=1
ERR_DIR=11
ERR_EVT=12
ERR_BKG=13
ERR_REG=14
ERR_ASOL=21
ERR_BPIX=22
ERR_PBK=23
ERR_MSK=24
ERR_BKGTY=31
ERR_SPEC=32
ERR_DET=41
## error code }}}

## usage, help {{{
case "$1" in
    -[hH]*|--[hH]*)
        printf "usage:\n"
        printf "    `basename $0` evt=<raw_evt_file>\n"
        printf "\nversion:\n"
        printf "    ${VERSION}, ${UPDATED}\n"
        exit ${ERR_USG}
        ;;
esac
## usage, help }}}

## default parameters {{{
# default `event file' which used to match `blanksky' files
#DFT_EVT="_NOT_EXIST_"
DFT_EVT="`\ls acisf?????*_repro_evt2.fits 2> /dev/null`"
## default parameters }}}

## functions {{{
# process commandline arguments
# cmdline arg format: `KEY=VALUE'
getopt_keyval() {
    until [ -z "$1" ]
    do
        key=${1%%=*}                    # extract key
        val=${1#*=}                     # extract value
        keyval="${key}=\"${val}\""
        echo "## getopt: eval '${keyval}'"
        eval ${keyval}
        shift                           # shift, process next one
    done
}
## functions }}}

## parameters {{{
# process cmdline args using `getopt_keyval'
getopt_keyval "$@"

# check given parameters
# check evt file
if [ -r "${evt}" ]; then
    EVT=${evt}
elif [ -r "${DFT_EVT}" ]; then
    EVT=${DFT_EVT}
else
    read -p "evt2 file: " EVT
    if ! [ -r "${EVT}" ]; then
        printf "ERROR: cannot access given \`${EVT}' evt file\n"
        exit ${ERR_EVT}
    fi
fi
printf "## use evt file: \`${EVT}'\n"
## parameters }}}

## prepare parameter files (pfiles) {{{
CIAO_TOOLS="dmkeypar dmcopy celldetect dmextract"

# Copy necessary pfiles for localized usage
for tool in ${CIAO_TOOLS}; do
    pfile=`paccess ${tool}`
    [ -n "${pfile}" ] && punlearn ${tool} && cp -Lvf ${pfile} .
done

# Modify environment variable 'PFILES' to use local pfiles first
export PFILES="./:${PFILES}"
## pfiles }}}

## determine ACIS type {{{
punlearn dmkeypar
DETNAM=`dmkeypar ${EVT} DETNAM echo=yes`
if echo ${DETNAM} | \grep -q 'ACIS-0123'; then
    printf "## \`DETNAM' (${DETNAM}) has chips 0123\n"
    printf "## ACIS-I\n"
    ACIS_TYPE="ACIS-I"
    CCD="0:3"
    ROOTNAME="evt2_c`echo ${CCD} | tr ':' '-'`"
elif echo ${DETNAM} | \grep -q 'ACIS-[0-6]*7'; then
    printf "## \`DETNAM' (${DETNAM}) has chip 7\n"
    printf "## ACIS-S\n"
    ACIS_TYPE="ACIS-S"
    CCD="7"
    ROOTNAME="evt2_c${CCD}"
else
    printf "ERROR: unknown detector type: ${DETNAM}\n"
    exit ${ERR_DET}
fi
## ACIS type }}}

## main process {{{
printf "filter raw evt2 file by ccd_id ...\n"
EVT2_ORIG="${ROOTNAME}_orig.fits"
punlearn dmcopy
dmcopy infile="${EVT}[ccd_id=${CCD}]" outfile=${EVT2_ORIG} clobber=yes

# detect point sources
printf "using \`celldetect' to find the point sources ...\n"
CELLD="celld_${ROOTNAME}"
[ -e "${CELLD}.reg" ] && mv -fv ${CELLD}.reg ${CELLD}.reg_bak
punlearn celldetect
celldetect infile=${EVT2_ORIG} outfile="${CELLD}.fits" \
    regfile="${CELLD}.reg" clobber=yes

printf "check the result of \`celldetect' ...\n"
printf "modify if necessary and save as the same name, \`${CELLD}.reg'\n"
cp -fv ${CELLD}.reg ${CELLD}_orig.reg
ds9 ${EVT2_ORIG} -region ${CELLD}.reg

EVT2_RMSRCS="${ROOTNAME}_rmsrcs.fits"
punlearn dmcopy
dmcopy infile="${EVT2_ORIG}[exclude sky=region(${CELLD}.reg)]" \
    outfile=${EVT2_RMSRCS} clobber=yes

LC_REG="ex_bkg.reg"
printf "filter flares ...\n"
printf "select a big source region and save as \`${LC_REG}'\n"
touch ${LC_REG}
ds9 ${EVT2_RMSRCS}

printf "create the lightcurve ...\n"
LC="${LC_REG%.reg}.lc"
[ -e "${LC}" ] && mv -fv ${LC} ${LC}_bak
punlearn dmextract
dmextract infile="${EVT2_RMSRCS}[exclude sky=region(${LC_REG})][bin time=::200]" \
    outfile="${LC}" opt=ltc1 clobber=yes

# generate a script for `chips'
# for convenience and backup
LC_SCRIPT="_${LC%.lc}.chips"
LC_SCALE=1.2
GTI="${LC%.lc}.gti"
cat > ${LC_SCRIPT} << _EOF_
from lightcurves import *
lc_clean("${LC}")
lc_clean("${LC}", scale=${LC_SCALE}, outfile="${GTI}")
print_window("${LC%.lc}_lc.jpg", ["format", "jpg", "clobber", "True"])
_EOF_

printf "generate GTI ...\n"
# [-x] let chips run in a separate terminal
chips -x ${LC_SCRIPT}

printf "remove the background flare ...\n"
EVT2_CLEAN="${ROOTNAME}_clean.fits"
punlearn dmcopy
dmcopy infile="${EVT2_RMSRCS}[@${GTI}]" outfile=${EVT2_CLEAN} clobber=yes
## main process }}}

printf "FINISHED\n"


